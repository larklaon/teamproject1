# 요구사항 구현 체크리스트 (확장 요소 제외)

| 요구사항 | 구현 위치 | 비고 |
|---|---|---|
| **CSV 데이터 처리** | `caffee_map.py`, `caffee_map_detailed.py`<br>함수: `load_and_analyze_data` | 3개 CSV 불러오기, 병합, 정렬 |
| **카테고리 변환(딕셔너리 매핑)** | `caffee_map.py`, `caffee_map_detailed.py`<br>함수: `load_and_analyze_data` | category → struct_name 매핑 |
| **시각화 좌표계 설계** | `map_draw.py`, `map_draw_detailed.py`<br>함수: `create_map_visualization`<br>`plt.xlim`, `plt.ylim` | (1,1) 좌상단, (x_max, y_max) 우하단 |
| **도형별 조건 시각화/겹침 우선순위** | `map_draw.py`, `map_draw_detailed.py`<br>함수: `create_map_visualization`<br>구조물별 도형/색상/크기/범례 | 구조물 종류별 시각화, 범례, 우선순위 |
| **이미지 저장 (PNG)** | `map_draw.py`, `map_draw_detailed.py`<br>함수: `create_map_visualization`<br>`plt.savefig()` | 지도/경로 PNG 저장 |
| **최단 경로 알고리즘 구현(BFS)** | `map_direct_save.py`, `map_direct_save_detailed.py`<br>함수: `bfs_pathfinding` | BFS 직접 구현, 외부 라이브러리 미사용 |
| **장애물 처리** | `map_direct_save.py`, `map_direct_save_detailed.py`<br>함수: `create_grid`, `bfs_pathfinding` | 건설현장/아파트/빌딩 통과 불가 |
| **결과 저장 (경로 CSV)** | `map_direct_save.py`, `map_direct_save_detailed.py`<br>함수: `save_path_to_csv` | 경로 좌표 목록 CSV 저장 |

---

## 💡 최단 경로 알고리즘(BFS) 쉽게 설명

### ● BFS란?
- **BFS**는 'Breadth-First Search'의 약자예요. 우리말로는 '너비 우선 탐색'이라고 해요.
- 미로 찾기, 지도에서 가장 빠른 길 찾기 등에 자주 쓰이는 방법이에요.
- 한 칸씩, 여러 방향으로 동시에 퍼져나가면서 가장 먼저 도착점에 도달하는 길을 찾아줘요.

### ● 이 프로젝트에서 BFS는 어떻게 쓰이나요?
- 내 집(시작점)에서 반달곰 커피(도착점)까지, 장애물을 피해 가장 빠른 길을 찾아요.
- 장애물(공사장, 아파트, 빌딩)은 못 지나가게 막아요.

### ● 동작 원리 (아주 쉽게!)
1. **시작점**을 큐(queue)라는 곳에 넣어요. (큐는 먼저 들어온 게 먼저 나가는 줄 같은 곳!)
2. 큐에서 하나씩 꺼내서, 그 칸에서 갈 수 있는 모든 방향(위, 아래, 왼쪽, 오른쪽, 대각선 등)으로 한 칸씩 이동해봐요.
3. 이동할 수 있는 칸(장애물이 아니고, 아직 안 가본 곳)이면, 그 칸을 다시 큐에 넣어요.
4. 이렇게 계속 퍼져나가다가, **도착점**에 처음 도착하면 그때의 경로가 '가장 빠른 길'이 돼요.
5. 만약 도착점에 도달할 수 없으면, "길이 없습니다"라고 알려줘요.

### ● 코드 흐름 예시 (초보자용 설명)
```python
from collections import deque

def bfs_pathfinding(start, end, grid):
    queue = deque([(start, [start])])  # (현재 위치, 지금까지 온 길)
    visited = set([start])             # 이미 가본 곳은 또 안 가려고 기록
    directions = [(-1,0), (1,0), (0,-1), (0,1), ...]  # 위, 아래, 왼, 오, 대각선 등

    while queue:
        current, path = queue.popleft()  # 줄에서 하나 꺼내기
        if current == end:
            return path  # 도착하면 지금까지 온 길을 반환
        for dx, dy in directions:
            next_x = current[0] + dx
            next_y = current[1] + dy
            next_pos = (next_x, next_y)
            # 갈 수 있는 곳(장애물X, 범위 안, 안 가본 곳)만 큐에 넣기
            if (next_pos not in visited and is_valid_position(next_pos, grid) and grid[next_y][next_x] == 0):
                visited.add(next_pos)
                queue.append((next_pos, path + [next_pos]))
    return None  # 길이 없으면 None 반환
```

### ● 예시 그림
- (2,2)에서 (5,5)까지 갈 때, 장애물을 피해 여러 방향으로 한 칸씩 퍼져나가며 가장 빠른 길을 찾아요.
- 실제로는 코드가 자동으로 이 과정을 반복해서, 사람이 직접 그려보지 않아도 결과를 알려줘요.

### ● 이 코드를 통해 얻는 것
- 내 집에서 커피숍까지 가장 빠른 경로(좌표 목록)를 자동으로 찾아줍니다.
- 그 경로를 CSV 파일로 저장하고, 지도 위에 빨간 선으로 표시해줍니다.

---

**이렇게 BFS 알고리즘이 실제 코드로 구현되어 있어서, 코딩 초보도 쉽게 따라가며 이해할 수 있습니다!** 